{"version":3,"sources":["resources/bear.png","app-theme.ts","layouts/simple.styles.ts","layouts/simple.tsx","comnponents/no-camera.tsx","api/face.ts","comnponents/face.tsx","comnponents/main.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","theme","colorPrimary","colorGreen","colorBlue","colorCyan","colorRed","colorYellow","logsGray","logsBlack","palette","createUseStyles","require","mainLayout","height","position","display","flexDirection","alignItems","justifyContent","fontSize","color","width","flexGrow","backgroundColor","padding","overflowY","SimpleLayout","mainElement","styles","useStyles","Navbar","Brand","src","bear","className","alt","Collapse","id","Text","HalfColsLayoutThemeWrapper","props","NoCamera","loadModels","a","MODEL_URL","process","faceapi","getFullFaceDescription","blob","inputSize","scoreThreshold","useTinyModel","img","withFaceLandmarks","fullDesc","createMatcher","faceProfile","members","Object","keys","labeledDescriptors","map","member","name","descriptors","descriptor","Float32Array","faceMatcher","getOverlayValues","landmarks","console","log","nose","getNose","jawline","getJawOutline","jawLeft","jawRight","splice","adjacent","x","opposite","y","Math","sqrt","pow","angle","atan2","PI","leftOffset","topOffset","getRandomMask","masks","push","floor","length","random","JSON_PROFILE","VideoInput","webcam","interval","componentWillMount","setState","setInputDevice","navigator","mediaDevices","enumerateDevices","then","devices","filter","device","kind","facingMode","exact","startCapture","setInterval","capture","current","getScreenshot","overlayValues","detections","state","findBestMatch","match","React","createRef","clearInterval","this","videoConstraints","camera","drawBox","detection","i","overlay","document","createElement","style","cssText","WIDTH","_X","_Y","key","left","top","transform","audio","ref","screenshotFormat","Component","Main","useState","camOn","setCam","setRadioValue","e","ButtonGroup","toggle","ToggleButton","type","variant","value","checked","onClick","App","Boolean","window","location","hostname","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.4923d440.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/bear.bed92471.png\";","const theme = {\n  colorPrimary: '#011f43',\n\n  colorGreen: \"#5CB85C\",\n  colorBlue: \"#1C7CD5\",\n  colorCyan: \"#56C0E0\",\n  colorRed: \"#D9534F\",\n  colorYellow: \"#FFC108\",\n  logsGray: \"#2B2B2B\",\n  logsBlack: \"#191919\",\n\n  palette: [\n    //Grayscale\n    \"white\",\n    \"#DDDDDD\",\n    \"#777777\",\n    \"#55595C\",\n    \"#373A3C\",\n  ]\n}\n\nexport type ITheme = typeof theme;\n\nexport default theme;","import { ITheme } from \"../app-theme\";\n\nconst { createUseStyles } = require('react-jss');\n\nexport default createUseStyles((theme: ITheme) => {\n  return {\n    mainLayout: {\n      //   minWidth: \"1280px\",\n      //   maxWidth: \"1600px\",\n      height: \"100vh\",\n      position: \"relative\",\n      display: \"flex\",\n      flexDirection: \"row\",\n\n      alignItems: \"center\",\n      justifyContent: \"center\",\n      fontSize: \"12pt\",\n      color: \"white\",      \n\n      \"& > .simple-column\": {\n        //width: \"calc(100% - 1152px)\",\n        //minWidth: \"1280px\",\n        //maxWidth: \"1600px\",\n        width: \"100%\",\n        height: \"100%\",\n        flexGrow: 1,\n        color: theme.palette[4],\n        backgroundColor: theme.palette[0],\n        padding: \"100px 100px 50px 50px\",\n        overflowY: \"scroll\"\n      }      \n    }\n  }\n})","import React from 'react';\n\nimport { ThemeProvider } from 'react-jss';\nimport theme from '../app-theme';\n\nimport useStyles from './simple.styles';\nimport Navbar from 'react-bootstrap/Navbar';\n\n// import {NavDropdown, Nav} from \"react-bootstrap/\";\nimport bear from \"../resources/bear.png\"\n\nimport \"../App.css\"\n\nexport interface Props {\n    mainElement: React.ReactElement;    \n}\n\nconst HalfColsLayoutThemeWrapper: React.FC<Props> = props =>\n  <ThemeProvider theme={ theme }>\n    <SimpleLayout { ...props } />\n    </ThemeProvider>\n\nconst SimpleLayout: React.FC<Props> = ({ mainElement }) => {\n  const styles = useStyles();\n\n  return (\n    <div>\n      {/* <Navbar fixed=\"top\" bg=\"dark\" variant=\"dark\" style = {{ height: '84px' }}> */}\n      <Navbar>\n        <Navbar.Brand>\n          <img          \n            src={bear}\n            height = \"70\"\n            className= \"d-inline-block align-top App-logo\"            \n            alt = \"kumar-logo\"\n          />\n        </Navbar.Brand>        \n        <Navbar.Collapse id=\"basic-navbar-nav\">\n          <Navbar.Text>\n          ようこそ！熊AR\n          </Navbar.Text>                    \n        </Navbar.Collapse>\n      </Navbar>\n      <div className = { styles.mainLayout } >        \n      <div className = \"simple-column\" >\n        { mainElement }\n      </div>\n      </div>\n    </div>\n  );\n}\n\nexport default HalfColsLayoutThemeWrapper;","import React from \"react\"\n\nfunction NoCamera() {\n  return <div>\n    <img\n      src={\"https://cdn.pixabay.com/photo/2017/02/12/21/29/false-2061132_960_720.png\"}      \n      className=\"d-inline-block align-top\"\n      height={50}\n      alt=\"camera-logo\"\n    />\n    <span>カメラ信号を受信できませんでした</span>\n  </div>\n}\n\nexport default NoCamera","import * as faceapi from 'face-api.js';\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + '/models';    \n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n  await faceapi.loadFaceRecognitionModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob: any, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.5;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  let fullDesc = await faceapi\n    .detectSingleFace(img, new faceapi.TinyFaceDetectorOptions())\n    // .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n    // .withFaceDescriptor();\n    // .withFaceDescriptors();\n  return fullDesc;\n}\n\nconst maxDescriptorDistance = 0.5;\nexport async function createMatcher(faceProfile: any) {\n  // Create labeled descriptors of member from profile\n  let members = Object.keys(faceProfile);\n  let labeledDescriptors = members.map(\n    member =>\n      new faceapi.LabeledFaceDescriptors(\n        faceProfile[member].name,\n        faceProfile[member].descriptors.map(\n          (descriptor:any) => new Float32Array(descriptor)\n        )\n      )\n  );\n\n  // Create face matcher (maximum descriptor distance is 0.5)\n  let faceMatcher = new faceapi.FaceMatcher(\n    labeledDescriptors,\n    maxDescriptorDistance\n  );\n  return faceMatcher;\n}\n\nexport const getOverlayValues = (landmarks:any) => {\n  console.log(\"landmarks\",landmarks);\n  const nose = landmarks.getNose()\n  const jawline = landmarks.getJawOutline()\n\n  const jawLeft = jawline[0]\n  const jawRight = jawline.splice(-1)[0]\n  const adjacent = jawRight.x - jawLeft.x\n  const opposite = jawRight.y - jawLeft.y\n  const jawLength = Math.sqrt(Math.pow(adjacent, 2) + Math.pow(opposite, 2))\n\n  // Both of these work. The chat believes atan2 is better.\n  // I don't know why. (It doesn’t break if we divide by zero.)\n  // const angle = Math.round(Math.tan(opposite / adjacent) * 100)\n  const angle = Math.atan2(opposite, adjacent) * (180 / Math.PI)\n  const width = jawLength * 2.2\n\n  return {\n    width,\n    angle,\n    leftOffset: jawLeft.x - width * 0.27,\n    topOffset: nose[0].y - width * 0.47,\n  }\n}\n\n// const getRandomMask = (masks:string[]) => {\n  \nexport const getRandomMask = () => {\n  const MODEL_URL = process.env.PUBLIC_URL + '/masks';\n  const blue = MODEL_URL+\"/overlay-blue-monster.png\"  \n\n  const masks: string[] = [];\n  masks.push(blue);\n  // const index = Math.floor(masks.length * Math.random())\n  const index = Math.floor(masks.length * Math.random())\n\n  return masks[index]\n}\n","import React, { Component } from 'react';\nimport Webcam from 'react-webcam';\nimport { loadModels, getFullFaceDescription, createMatcher, getOverlayValues, getRandomMask } from '../api/face';\n\n// Import face profile\nconst JSON_PROFILE = require('../descriptors/bnk48.json');\n\nconst WIDTH = 420;\nconst HEIGHT = 420;\nconst inputSize = 160;\n\ninterface IVideoInputState {\n    fullDesc: any;\n    detections: any;\n    descriptors: any;\n    faceMatcher: any;\n    match: any;\n    facingMode: any;\n}\n\n\nclass VideoInput extends Component<{},IVideoInputState> {\n  webcam: React.RefObject<Webcam>;\n  interval: NodeJS.Timeout ;\n//   webcam: Webcam;\n  constructor(props: any) {\n    super(props);\n    this.interval = setInterval(() => {},1500);\n    this.webcam = React.createRef<Webcam>();\n    this.state = {\n      fullDesc: null,\n      detections: null,\n      descriptors: null,\n      faceMatcher: null,\n      match: null,\n      facingMode: ''\n    };\n  }\n\n  componentWillMount = async () => {\n    await loadModels();    \n    this.setState({ faceMatcher: await createMatcher(JSON_PROFILE) });\n    this.setInputDevice();\n  };\n\n  setInputDevice = () => {\n    navigator.mediaDevices.enumerateDevices().then(async devices => {      \n      let inputDevice = await devices.filter(\n        device => device.kind === 'videoinput'\n      );\n      if (inputDevice.length < 2) {\n        await this.setState({\n          facingMode: 'user'\n        });\n      } else {\n        await this.setState({\n          facingMode: { exact: 'environment' }\n        });\n      }\n      this.startCapture();\n    });\n  };\n\n  startCapture = () => {\n    this.interval = setInterval(() => {\n      this.capture();\n    }, 1500);\n  };\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  capture = async () => {\n    if (!!this.webcam.current) {\n      await getFullFaceDescription(\n        this.webcam.current.getScreenshot(),\n        inputSize\n      ).then(fullDesc => {\n        if (!!fullDesc) {\n          // const scale = originalImage.width / originalImage.naturalWidth\n          // const scale = 10;\n          const overlayValues = getOverlayValues(fullDesc.landmarks)\n          // console.log(\"overlayValues\",overlayValues);\n          // const overlay = document.createElement(\"img\")\n          // overlay.src = getRandomMask()\n          // overlay.alt = \"mask overlay.\"\n          // overlay.style.cssText = `\n          // position: absolute;\n          // left: ${overlayValues.leftOffset * scale}px;\n          // top: ${overlayValues.topOffset * scale}px;\n          // width: ${overlayValues.width * scale}px;\n          // transform: rotate(${overlayValues.angle}deg);\n        \n\n          this.setState({\n            detections: [overlayValues]\n          })\n          // item.appendChild(overlay)\n          // const overlayValues = fullDesc.landmarks;\n          // this.setState({\n          //   detections: fullDesc.map(fd => fd.detection),\n          //   descriptors: fullDesc.map(fd => fd.descriptor)\n          // });\n        }\n      });\n\n      if (!!this.state.descriptors && !!this.state.faceMatcher) {\n        let match = await this.state.descriptors.map((descriptor:any) =>\n          this.state.faceMatcher.findBestMatch(descriptor)\n        );\n        this.setState({ match });\n      }\n    }\n  };\n\n  render() {\n    const { detections, match, facingMode } = this.state;\n    let videoConstraints = null;\n    let camera = '';\n    if (!!facingMode) {\n      videoConstraints = {\n        width: WIDTH,\n        height: HEIGHT,\n        facingMode: facingMode\n      };\n      if (facingMode === 'user') {\n        camera = 'Front';\n      } else {\n        camera = 'Back';\n      }\n    }\n\n    let drawBox = null;\n    if (!!detections) {\n      drawBox = detections.map((detection:any, i:number) => {\n        console.log(\"Detection\",detection);\n        const overlayValues = detection;\n        // console.log(\"overlayValues\",overlayValues);\n        // let scale = 10;\n        const scale = WIDTH / HEIGHT;\n        const overlay = document.createElement(\"img\")\n        overlay.src = getRandomMask()\n        overlay.alt = \"mask overlay.\"\n        overlay.style.cssText = `\n        position: absolute;\n        left: ${overlayValues.leftOffset * scale}px;\n        top: ${overlayValues.topOffset * scale}px;\n        width: ${overlayValues.width * scale}px;\n        transform: rotate(${overlayValues.angle}deg);\n        `\n\n        let _X = overlayValues.leftOffset;\n        let _Y = overlayValues.topOffset;\n        return (\n            <div key={i}>\n              <img              \n                src={getRandomMask()}\n                style={{\n                  position: 'absolute', \n                  left: `${overlayValues.leftOffset * scale}px;`,\n                  top: `${overlayValues.topOffset * scale}px;`,\n                  width: `${overlayValues.width * scale}px;`,\n                  transform: `rotate(${overlayValues.angle}deg) translate(${_X}px,${_Y}px) `,\n                  // transform: `translate(${_X}px,${_Y}px)`\n                }}\n              ></img>                             \n            </div>\n        );\n\n\n\n\n        // OLD STUFF\n        // console.log(\"DETECTOU!\",detection);\n        // let _H = detection.box.height;\n        // let _W = detection.box.width;\n        // let _X = detection.box._x;\n        // let _Y = detection.box._y;\n        // return (\n        //   <div key={i}>\n        //     <div\n        //       style={{\n        //         position: 'absolute',\n        //         border: 'solid',\n        //         borderColor: 'red',\n        //         height: _H,\n        //         width: _W,\n        //         transform: `translate(${_X}px,${_Y}px)`\n        //       }}\n        //     >\n        //       {!!match && !!match[i] ? (\n        //         <p\n        //           style={{\n        //             backgroundColor: 'blue',\n        //             border: 'solid',\n        //             borderColor: 'blue',\n        //             width: _W,\n        //             marginTop: 0,\n        //             color: '#fff',\n        //             transform: `translate(-3px,${_H}px)`\n        //           }}\n        //         >\n        //           {match[i]._label}\n        //         </p>\n        //       ) : null}\n        //     </div>\n        //   </div>\n        // );\n      });\n    }\n\n    return (\n      <div\n        className=\"Camera\"\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'center'\n        }}\n      >\n        <p>Camera: {camera}</p>\n        <div\n          style={{\n            width: WIDTH,\n            height: HEIGHT\n          }}\n        >\n          <div style={{ position: 'relative', width: WIDTH }}>\n            {!!videoConstraints ? (\n              <div style={{ position: 'absolute' }}>\n                <Webcam\n                  audio={false}\n                  width={WIDTH}\n                  height={HEIGHT}\n                  ref={this.webcam as any}\n                  screenshotFormat=\"image/jpeg\"\n                  videoConstraints={videoConstraints}\n                />\n              </div>\n            ) : null}\n            {!!drawBox ? drawBox : null}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default VideoInput;","import React, { useState } from 'react';\n\nimport ToggleButton from 'react-bootstrap/ToggleButton'\nimport ButtonGroup from \"react-bootstrap/ButtonGroup\"\nimport NoCamera from \"./no-camera\";\nimport FaceDetectionComponent from \"./face\";\n\nfunction Main() {  \n\n  const [camOn, setCam] = useState<boolean>(false);\n\n  const setRadioValue = (e: boolean) => {\n    setCam(e);\n  }\n\n  return <div>\n    {/* {camOn ? <Camera/> : <NoCamera/>} */}\n    {/* {camOn ? <PoseComponent /> : <NoCamera />} */}\n    {camOn ? <FaceDetectionComponent /> : <NoCamera />}\n    <ButtonGroup toggle>\n      <ToggleButton\n        key={\"0\"}\n        type=\"radio\"\n        variant=\"secondary\"\n        name=\"radio\"\n        value={\"ON\"}\n        checked={camOn}\n        onClick={(e) => setRadioValue(true)}\n      >オン\n        </ToggleButton>\n      <ToggleButton\n        key={\"1\"}\n        type=\"radio\"\n        variant=\"secondary\"\n        name=\"radio\"\n        value={\"OFF\"}\n        checked={!camOn}\n        onClick={(e) => setRadioValue(false)}\n      >オフ\n        </ToggleButton>\n    </ButtonGroup>\n    \n  </div>\n}\n\nexport default Main;\n","import React from 'react';\nimport './App.css';\nimport HalfLayout from \"./layouts/half\"\nimport SimpleLayout from \"./layouts/simple\";\nimport MainComponent from \"./comnponents/main\"\n\nfunction App() {\n  // return <HalfLayout leftColumn={<div />} rightColumn={<MainComponent/>} />  \n  return <SimpleLayout mainElement={<MainComponent/>} />  \n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}